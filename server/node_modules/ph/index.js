// Generated by CoffeeScript 1.9.2

/* PH - a better git push */

(function() {
  var GitPush, _, args, argv, async, chalk, exec, exists, inquirer, isGitRepo, pkg, ref, spawn,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  inquirer = require("inquirer");

  ref = require("child_process"), exec = ref.exec, spawn = ref.spawn;

  exists = require("fs").exists;

  chalk = require("chalk");

  pkg = require("./package.json");

  _ = require("underscore");

  async = require("async");

  args = process.argv.slice(2).join(' ');

  if (args[0] !== '-') {
    args = "-" + args;
  }

  args = args.split(" ");

  argv = require("minimist")(args);

  isGitRepo = function(cb, iter) {
    var i, pre;
    if (iter == null) {
      iter = 1;
    }
    if (iter === 0) {
      pre = "./";
    } else {
      pre = ((function() {
        var j, ref1, results1;
        results1 = [];
        for (i = j = 0, ref1 = iter - 1; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
          results1.push("../");
        }
        return results1;
      })()).join('');
    }
    return exists(pre + ".git", function(good) {
      if (good) {
        return cb(true);
      } else if (iter <= (process.env.PH_SEARCH_GIT_REPO_AMT || 20)) {
        return isGitRepo(cb, iter + 1);
      } else {
        return cb(false);
      }
    });
  };

  GitPush = (function() {
    function GitPush(argv1) {
      var action;
      this.argv = argv1;
      this.getBranch = bind(this.getBranch, this);
      this.getRemote = bind(this.getRemote, this);
      if (this.argv.help || this.argv['?']) {
        console.log(this.help());
        return;
      }
      if (this.argv.v || this.argv.version) {
        console.log("ph - version " + (chalk.cyan(pkg.version)) + "\nRun " + (chalk.blue("--help")) + " for help");
        return;
      }
      if (this.argv.pull || this.argv.l) {
        action = "pull";
      } else {
        action = "push";
      }
      this.getRemote((function(_this) {
        return function(remote1) {
          _this.remote = remote1;
          return _this.getBranch(function(branches1, pushToBranch) {
            var extra, ignoreFlags;
            _this.branches = branches1;
            _this.pushToBranch = pushToBranch;
            ignoreFlags = ["_", "pull", "remote", "branch", "origin", "current-branch", "v", "q", "n", "o", "h", "p", "m", "d", "c", "l"];
            extra = Object.keys(_this.argv).map(function(k) {
              if (indexOf.call(ignoreFlags, k) < 0) {
                if (typeof _this.argv[k] === "boolean") {
                  if (k.length === 1) {
                    return "-" + k;
                  } else {
                    return "--" + k;
                  }
                } else {
                  return "--" + k + " " + _this.argv[k];
                }
              } else {
                return "";
              }
            });
            extra = extra.join(" ").trim(" ");
            return async.forEach(_.uniq(_this.branches), function(branch, cb) {
              var child, onData;
              if (_this.pushToBranch === branch || !_this.pushToBranch) {
                _this.pushToBranch = "";
              } else {
                _this.pushToBranch = ":" + _this.pushToBranch;
              }
              console.log(["----->", "git", action, chalk.magenta(_this.remote), "" + (chalk.cyan(branch)) + (chalk.bgBlue(_this.pushToBranch)), extra].join(" "));
              child = spawn("git", _.compact([action, _this.remote, branch, _this.pushToBranch, extra]));
              onData = function(buffer) {
                var s;
                s = buffer.toString().trim('\n');
                if (_this.branches.length !== 1) {
                  branch = "(" + (chalk.cyan(branch.trim())) + ") ";
                } else {
                  branch = "";
                }
                if (s.indexOf("up-to-date") !== -1) {
                  return console.log("-----> " + (chalk.green(s)) + " " + branch);
                } else if (s.indexOf("fatal: ") !== -1) {
                  return console.log("-----> " + (chalk.red(s)) + " " + branch);
                } else if (s.length) {
                  return console.log(branch + s);
                }
              };
              cb = _.once(cb);
              child.stdout.on('data', onData);
              child.stderr.on('data', onData);
              child.stdout.on('end', function() {
                return cb(null);
              });
              return child.stderr.on('end', function(buffer) {
                return cb(buffer);
              });
            }, function(err, results) {
              if (err) {
                return console.log("-----> Error, aborting.");
              } else {
                return console.log("+1");
              }
            });
          });
        };
      })(this));
    }

    GitPush.prototype.getRemote = function(cb) {
      var remote;
      if (this.argv.o || this.argv.origin) {
        return cb("origin");
      }
      if (this.argv.h || this.argv.heroku) {
        return cb("heroku");
      }
      if (this.argv.p || this.argv.prod) {
        return cb("production");
      }
      if (this.argv.u || this.argv.upstream) {
        return cb("upstream");
      }
      if (!(this.argv.r || this.argv.remote)) {
        return exec("git remote", function(err, remotes) {
          var r;
          r = remotes.trim("\n").split("\n");
          return inquirer.prompt([
            {
              name: "remote",
              message: "---> remote?",
              "default": "origin",
              type: "list",
              choices: r
            }
          ], function(answers) {
            var remote;
            remote = answers.remote;
            return cb(remote);
          });
        });
      } else {
        remote = this.argv.r || this.argv.remote;
        return cb(remote);
      }
    };

    GitPush.prototype.getBranch = function(cb) {
      var branch, currentBranch, pushBranches;
      currentBranch = "master";
      pushBranches = [];
      if (this.argv.m || this.argv.master) {
        pushBranches.push("master");
      }
      if (this.argv.d || this.argv.dev) {
        pushBranches.push("dev");
      }
      if (!(this.argv.b || this.argv.branch)) {
        return exec("git branch", (function(_this) {
          return function(err, branches) {
            var b;
            b = branches.trim('\n').split('\n').map(function(b) {
              if (b[0] === "*") {
                currentBranch = b.slice(2);
                return currentBranch.trim();
              } else {
                b.trim();
                return b;
              }
            });
            if (_this.argv.c || _this.argv["current-branch"]) {
              pushBranches.push(currentBranch);
            }
            if (pushBranches.length) {
              return cb(pushBranches);
            }
            if (indexOf.call(b, "master") < 0) {
              b = ["master"].concat(b);
            }
            return inquirer.prompt([
              {
                name: "branch",
                message: "---> branch?",
                type: "list",
                choices: b,
                "default": currentBranch
              }, {
                name: "pushto",
                message: "---> to which remote branch?",
                type: "list",
                choices: b,
                "default": currentBranch
              }
            ], function(answers) {
              return cb([answers.branch], answers.pushto);
            });
          };
        })(this));
      } else {
        branch = this.argv.b || this.argv.branch;
        return cb([branch]);
      }
    };

    GitPush.prototype.help = function() {
      return "Usage: ph [options]\n\n" + (chalk.bold(chalk.yellow("== Action =="))) + "\nBy default, do a git push.\nHowever, by specifing " + (chalk.green("--pull")) + " or " + (chalk.green("-l")) + "\nthis behavior can be switched, so a pull will occur instead.\n\n" + (chalk.bold(chalk.yellow("== Branch Choices =="))) + "\n" + (chalk.cyan("-m")) + " branch = master\n" + (chalk.cyan("-d")) + " branch = dev\n" + (chalk.cyan("-c")) + " branch = currently active branch\n\n" + (chalk.bold(chalk.yellow("== Remote Choices =="))) + "\n" + (chalk.magenta("-o")) + " remote = origin\n" + (chalk.magenta("-h")) + " remote = heroku\n" + (chalk.magenta("-p")) + " remote = production\n" + (chalk.magenta("-u")) + " remote = upstream\n\nAny other arguments are just passed through to git push/pull.\n\n== Examples ==\n" + (chalk.blue("ph c")) + " or " + (chalk.blue("ph --current-branch")) + "\n- ask for the remote but push to the current branch.\n\n" + (chalk.blue("ph oc")) + " or " + (chalk.blue("ph --remote origin --current-branch")) + "\n- push to origin the current branch.\n\n" + (chalk.blue("ph hm")) + " or " + (chalk.blue("ph -h -m")) + " or " + (chalk.blue("ph --remote heroku --branch master")) + "\n- push to heroku the master branch.\n\n" + (chalk.blue("ph oml")) + " or " + (chalk.blue("ph --pull --branch master --remote origin")) + "\n- pull from master the current branch.";
    };

    return GitPush;

  })();

  exports.GitPush = GitPush;

  isGitRepo(function(doesit) {
    if (doesit || argv.help || argv['?']) {
      return new GitPush(argv);
    } else {
      return console.log(chalk.red("This isn't a git repo!"));
    }
  });

}).call(this);
